---
title: 'Next å­¦ä¹ ç¬”è®°ï¼ˆä¸‰ï¼‰ï¼šæ•°æ®è·å–'
date: '2025-04-03'
overview: 'åœ¨ç†è§£äº†æœåŠ¡ç«¯ç»„ä»¶ï¼ˆRSCï¼‰ä¹‹åï¼Œæ•°æ®è·å–å’Œæäº¤çš„æ¨¡å¼ä¹Ÿéšä¹‹å‘ç”Ÿäº†æ ¹æœ¬æ€§çš„å˜åŒ–ã€‚æ—§çš„ useEffect + fetch æ¨¡å¼ä¸å†æ˜¯é¦–é€‰ï¼Œæ–°çš„æ¨¡å¼å°†æ•°æ®è·å–å’Œå˜æ›´æ›´å¤šåœ°æ”¾åœ¨æœåŠ¡ç«¯å¤„ç†ï¼Œä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½å’Œæ›´ç®€æ´çš„ä»£ç ã€‚'
tags: 'Next'
slug: 'Study-Next-03'
---

## æœåŠ¡ç«¯ç»„ä»¶ä¸­çš„æ•°æ®è·å–

- **æ ¸å¿ƒæ€æƒ³ï¼š** åœ¨æœåŠ¡ç«¯ç»„ä»¶ï¼ˆRSCï¼‰ä¸­ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ `async/await` è¯­æ³•æ¥è·å–æ•°æ®ã€‚ç»„ä»¶æœ¬èº«å¯ä»¥æ˜¯ä¸€ä¸ªå¼‚æ­¥å‡½æ•°ã€‚Next.js æ‰©å±•äº†åŸç”Ÿçš„ `fetch` APIï¼Œä½¿å…¶èƒ½è‡ªåŠ¨å¤„ç†è¯·æ±‚çš„ç¼“å­˜å’Œé‡æ–°éªŒè¯ã€‚

- **ä¸æ—§æ¨¡å¼çš„å¯¹æ¯”ï¼š**

  - **æ—§æ¨¡å¼ï¼ˆå®¢æˆ·ç«¯ `useEffect`ï¼‰:** é¡µé¢ HTML å…ˆåŠ è½½ -> é¡µé¢ JS å†åŠ è½½ -> `useEffect` è§¦å‘ -> `fetch` å¼€å§‹ -> æ¸²æŸ“æ•°æ®ã€‚è¿™ä¸ªè¿‡ç¨‹ä¼šäº§ç”ŸåŠ è½½ç€‘å¸ƒï¼ˆrequest waterfallï¼‰ï¼Œç”¨æˆ·ä¼šå…ˆçœ‹åˆ°ä¸€ä¸ª loading çŠ¶æ€ã€‚
  - **æ–°æ¨¡å¼ï¼ˆRSC `async/await`ï¼‰:** åœ¨æœåŠ¡ç«¯ï¼Œæ•°æ®è·å–å’Œé¡µé¢æ¸²æŸ“å¯ä»¥å¹¶è¡Œå‘ç”Ÿã€‚æœ€ç»ˆç›´æ¥ç”ŸæˆåŒ…å«æ•°æ®çš„å®Œæ•´ HTML å‘é€ç»™æµè§ˆå™¨ã€‚ç”¨æˆ·èƒ½æ›´å¿«åœ°çœ‹åˆ°æœ€ç»ˆå†…å®¹ï¼Œå¯¹ SEO ä¹Ÿæ›´å‹å¥½ã€‚

- **ä»£ç ç¤ºä¾‹ï¼š** ä¸€ä¸ªå…¸å‹çš„ RSC æ•°æ®è·å–é¡µé¢ã€‚

  ```tsx
  // app/posts/page.tsx (è¿™æ˜¯ä¸€ä¸ªæœåŠ¡ç«¯ç»„ä»¶)
  
  interface Post {
    id: number;
    title: string;
  }
  
  // ç»„ä»¶å‡½æ•°æœ¬èº«å°±æ˜¯ async
  export default async function PostsPage() {
    // ç›´æ¥ await fetch è°ƒç”¨ã€‚å°±åƒåœ¨å†™åç«¯ä»£ç ä¸€æ ·ã€‚
    const res = await fetch('https://jsonplaceholder.typicode.com/posts');
    const posts: Post[] = await res.json();
  
    return (
      <div>
        <h1>Posts</h1>
        <ul>
          {posts.map(post => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
      </div>
    );
  }
  ```

## ç¼“å­˜ä¸é‡æ–°éªŒè¯ (Caching & Revalidation)

- **æ ¸å¿ƒæ¦‚å¿µï¼š** Next.js æ‰©å±•åçš„ `fetch` ä¼š**è‡ªåŠ¨ç¼“å­˜**æ‰€æœ‰è¯·æ±‚ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè¯·æ±‚ç»“æœä¼šè¢«æ°¸ä¹…ç¼“å­˜ï¼Œç›´åˆ°ä½ æ‰‹åŠ¨è®©å®ƒå¤±æ•ˆã€‚

- **æ§åˆ¶ç¼“å­˜è¡Œä¸ºï¼š** å¯ä»¥é€šè¿‡ `fetch` çš„ç¬¬äºŒä¸ªå‚æ•° `options` å¯¹è±¡æ¥ç²¾ç»†æ§åˆ¶ã€‚

  1. **ä¸ç¼“å­˜ï¼ˆåŠ¨æ€æ¸²æŸ“ï¼‰ï¼š** æ¯æ¬¡è¯·æ±‚éƒ½é‡æ–°è·å–æ•°æ®ï¼Œç­‰åŒäºæ—§çš„ `getServerSideProps`ã€‚

     ```tsx
     fetch('...', { cache: 'no-store' });
     ```

  2. **å®šæ—¶é‡æ–°éªŒè¯ï¼ˆISRï¼‰ï¼š** è·å–æ•°æ®å¹¶ç¼“å­˜ `n` ç§’ã€‚åœ¨ `n` ç§’åï¼Œå¦‚æœå†æœ‰æ–°è¯·æ±‚ï¼Œä¼šå…ˆè¿”å›æ—§çš„ç¼“å­˜æ•°æ®ï¼ŒåŒæ—¶åœ¨åå°é‡æ–°è¯·æ±‚æ–°æ•°æ®ï¼Œæ›´æ–°ç¼“å­˜ã€‚

     ```tsx
     // ç¼“å­˜ 1 å°æ—¶ (3600 ç§’)
     fetch('...', { next: { revalidate: 3600 } });
     ```

- **æŒ‰éœ€é‡æ–°éªŒè¯ï¼ˆOn-Demand Revalidationï¼‰ï¼š**

  - **é—®é¢˜åœºæ™¯ï¼š** åœ¨ CMSï¼ˆå†…å®¹ç®¡ç†ç³»ç»Ÿï¼‰é‡Œå‘å¸ƒäº†ä¸€ç¯‡æ–°æ–‡ç« ï¼Œå¸Œæœ›åšå®¢ç«‹å³æ˜¾ç¤ºå‡ºæ¥ï¼Œè€Œä¸æ˜¯ç­‰å¾… `revalidate` çš„æ—¶é—´ã€‚

  - **è§£å†³æ–¹æ¡ˆï¼š** `revalidateTag` å’Œ `revalidatePath`ã€‚å¯ä»¥åœ¨ä¸€ä¸ªæœåŠ¡ç«¯æ“ä½œï¼ˆå¦‚ API è·¯ç”±æˆ– Server Actionï¼‰ä¸­è°ƒç”¨è¿™äº›å‡½æ•°ï¼Œæ¥ç²¾ç¡®åœ°æ¸…é™¤æŒ‡å®šæ ‡ç­¾æˆ–è·¯å¾„çš„ç¼“å­˜ã€‚

  - **ç¤ºä¾‹ (`revalidateTag`)**

    1. åœ¨ `fetch` æ—¶ç»™æ•°æ®æ‰“ä¸Šæ ‡ç­¾ï¼š

       ```tsx
       fetch('https://my-cms/posts', { next: { tags: ['posts'] } });
       ```

    2. åˆ›å»ºä¸€ä¸ª API è·¯ç”±ï¼Œç”¨äºæ¥æ”¶ CMS çš„ webhook é€šçŸ¥ï¼š

       ```tsx
       // app/api/revalidate/route.ts
       import { NextRequest, NextResponse } from 'next/server';
       import { revalidateTag } from 'next/cache';
       
       export async function POST(request: NextRequest) {
         const tag = request.nextUrl.searchParams.get('tag');
       
         if (!tag) {
           return NextResponse.json({ error: 'Tag is required' }, { status: 400 });
         }
       
         revalidateTag(tag); // æ¸…é™¤æ‰€æœ‰å¸¦ 'posts' æ ‡ç­¾çš„ç¼“å­˜
         return NextResponse.json({ revalidated: true, now: Date.now() });
       }
       ```

    ç°åœ¨ï¼Œåªè¦è¯·æ±‚ `POST /api/revalidate?tag=posts`ï¼Œæ‰€æœ‰ç›¸å…³é¡µé¢çš„ç¼“å­˜å°±ä¼šç«‹å³å¤±æ•ˆï¼Œä¸‹æ¬¡è®¿é—®æ—¶ä¼šè·å–æœ€æ–°æ•°æ®ã€‚

## Server Actions: æœåŠ¡ç«¯çš„æ•°æ®å˜æ›´

- **æ ¸å¿ƒæ¦‚å¿µï¼š** Server Action æ˜¯ä¸€äº›**åªèƒ½åœ¨æœåŠ¡ç«¯è¿è¡Œ**çš„å‡½æ•°ï¼Œä½†å®ƒå¯ä»¥è¢«å®¢æˆ·ç«¯ç»„ä»¶ç›´æ¥è°ƒç”¨ï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡è¡¨å•æäº¤æˆ–æŒ‰é’®ç‚¹å‡»ï¼‰ï¼Œè€Œ**æ— éœ€æ‰‹åŠ¨åˆ›å»º API è·¯ç”±**ã€‚è¿™æ˜¯å¯¹æ•°æ®å˜æ›´ï¼ˆmutationsï¼‰æµç¨‹çš„å·¨å¤§ç®€åŒ–ã€‚

- **å¦‚ä½•å®šä¹‰ï¼š** åœ¨ä¸€ä¸ªå¼‚æ­¥å‡½æ•°å†…éƒ¨æˆ–ä¸€ä¸ªç‹¬ç«‹æ–‡ä»¶çš„é¡¶éƒ¨åŠ ä¸Š `'use server';` æŒ‡ä»¤ã€‚

- **ç¤ºä¾‹ï¼šè¡¨å•æäº¤**

  ```tsx
  // 1. åœ¨ Server Component ä¸­å®šä¹‰ Action
  // app/page.tsx
  import { revalidatePath } from 'next/cache';
  
  export default function Page() {
    async function createItem(formData: FormData) {
      'use server'; // å£°æ˜è¿™æ˜¯ä¸€ä¸ª Server Action
  
      const itemName = formData.get('itemName') as string;
      // ... å‡è®¾è¿™é‡Œæ˜¯ä¿å­˜åˆ°æ•°æ®åº“çš„é€»è¾‘
      await db.items.create({ name: itemName });
  
      // æ¸…é™¤å½“å‰é¡µé¢çš„ç¼“å­˜ï¼Œä»¥ä¾¿æ˜¾ç¤ºæ–°æ·»åŠ çš„é¡¹
      revalidatePath('/');
    }
  
    return (
      <form action={createItem}>
        <input type="text" name="itemName" />
        <button type="submit">Add Item</button>
      </form>
    );
  }
  ```

  åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå½“è¡¨å•æäº¤æ—¶ï¼Œ`createItem` å‡½æ•°ä¼šåœ¨æœåŠ¡ç«¯æ‰§è¡Œï¼Œå®Œæˆæ•°æ®åº“æ“ä½œï¼Œç„¶ååˆ·æ–°é¡µé¢æ•°æ®ï¼Œæ•´ä¸ªè¿‡ç¨‹æ²¡æœ‰å†™ä¸€è¡Œ `fetch` æˆ– API è·¯ç”±ä»£ç ã€‚

## è¡¨å•äº¤äº’å¢å¼ºï¼š`useActionState`

- **é—®é¢˜åœºæ™¯ï¼š** å½“ Server Action è¿è¡Œæ—¶ï¼Œå¦‚ä½•å¤„ç†åŠ è½½çŠ¶æ€ï¼ˆpendingï¼‰ï¼Œä»¥åŠå¦‚ä½•ä»æœåŠ¡ç«¯è¿”å›æˆåŠŸæˆ–é”™è¯¯æ¶ˆæ¯å¹¶æ˜¾ç¤ºåœ¨ç•Œé¢ä¸Šï¼Ÿ

- **è§£å†³æ–¹æ¡ˆï¼š** ä½¿ç”¨ React 19 æ–°å¢çš„ `useActionState` Hookï¼ˆå®ƒå–ä»£äº†æ—§çš„ `useFormState`ï¼‰ã€‚

- **ä»£ç ç¤ºä¾‹ï¼šå¸¦çŠ¶æ€åé¦ˆçš„è¡¨å•**

  1. ä¿®æ”¹ Action å‡½æ•°

     Action å‡½æ•°ç°åœ¨å¯ä»¥æ¥æ”¶å‰ä¸€ä¸ªçŠ¶æ€ï¼Œå¹¶è¿”å›æ–°çš„çŠ¶æ€ã€‚

     ```tsx
     // lib/actions.ts
     'use server';
     
     export async function updateUser(previousState: any, formData: FormData) {
       const username = formData.get('username') as string;
     
       try {
         await db.user.update({ name: username });
         revalidatePath('/profile');
         return { status: 'success', message: 'Profile updated successfully!' };
       } catch (e) {
         return { status: 'error', message: 'Failed to update profile.' };
       }
     }
     ```

  2. åœ¨å®¢æˆ·ç«¯ç»„ä»¶ä¸­ä½¿ç”¨ `useActionState`

     ```tsx
     // components/ProfileForm.tsx
     'use client';
     
     import { useActionState } from 'react';
     import { updateUser } from '@/lib/actions';
     
     const initialState = { status: '', message: '' };
     
     export function ProfileForm() {
       // useActionState è¿”å› [state, formAction, isPending]
       const [state, formAction, isPending] = useActionState(updateUser, initialState);
     
       return (
         <form action={formAction}>
           <input type="text" name="username" defaultValue="KK" />
           <button type="submit" disabled={isPending}>
             {isPending ? 'Saving...' : 'Save'}
           </button>
     
           {state.status === 'success' && <p className="text-green-500">{state.message}</p>}
           {state.status === 'error' && <p className="text-red-500">{state.message}</p>}
         </form>
       );
     }
     ```

  ç°åœ¨ï¼Œè¿™ä¸ªè¡¨å•æ‹¥æœ‰äº†è‡ªåŠ¨çš„ pending çŠ¶æ€ç®¡ç†å’Œæ¥è‡ªæœåŠ¡ç«¯çš„çŠ¶æ€æ¶ˆæ¯åé¦ˆï¼Œè€Œæ— éœ€æ‰‹å†™ä»»ä½• `useState` æˆ– `fetch` é€»è¾‘ã€‚

## ğŸš€ æ•°æ®è·å–æœ€ä½³å®è·µ

### å¹¶è¡Œæ•°æ®è·å–
```tsx
// âŒ ä¸²è¡Œè·å–ï¼ˆæ…¢ï¼‰
export default async function PostPage({ params }: { params: { id: string } }) {
  const post = await fetch(`/api/posts/${params.id}`).then(r => r.json());
  const comments = await fetch(`/api/posts/${params.id}/comments`).then(r => r.json());
  
  return <PostWithComments post={post} comments={comments} />;
}

// âœ… å¹¶è¡Œè·å–ï¼ˆå¿«ï¼‰
export default async function PostPage({ params }: { params: { id: string } }) {
  const [post, comments] = await Promise.all([
    fetch(`/api/posts/${params.id}`).then(r => r.json()),
    fetch(`/api/posts/${params.id}/comments`).then(r => r.json())
  ]);
  
  return <PostWithComments post={post} comments={comments} />;
}
```

### é”™è¯¯å¤„ç†ä¸é‡è¯•
```tsx
// å¥å£®çš„æ•°æ®è·å–å‡½æ•°
async function fetchWithRetry(url: string, retries = 3): Promise<any> {
  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return await response.json();
    } catch (error) {
      console.warn(`Attempt ${i + 1} failed:`, error);
      
      if (i === retries - 1) throw error; // æœ€åä¸€æ¬¡é‡è¯•å¤±è´¥æ—¶æŠ›å‡ºé”™è¯¯
      
      // æŒ‡æ•°é€€é¿
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
    }
  }
}

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
export default async function ReliableDataPage() {
  try {
    const data = await fetchWithRetry('https://api.example.com/data');
    return <DataDisplay data={data} />;
  } catch (error) {
    return <ErrorMessage error={error.message} />;
  }
}
```

### æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
```tsx
// âŒ N+1 æŸ¥è¯¢é—®é¢˜
export default async function PostsPage() {
  const posts = await db.post.findMany();
  
  const postsWithAuthors = await Promise.all(
    posts.map(async (post) => ({
      ...post,
      author: await db.user.findUnique({ where: { id: post.authorId } })
    }))
  );
  
  return <PostsList posts={postsWithAuthors} />;
}

// âœ… ä½¿ç”¨ include ä¸€æ¬¡æ€§è·å–å…³è”æ•°æ®
export default async function PostsPage() {
  const postsWithAuthors = await db.post.findMany({
    include: {
      author: true,
      comments: {
        take: 5, // åªè·å–å‰5æ¡è¯„è®º
        orderBy: { createdAt: 'desc' }
      }
    }
  });
  
  return <PostsList posts={postsWithAuthors} />;
}
```

## ğŸ› ï¸ Server Actions è¿›é˜¶æŠ€å·§

### è¡¨å•éªŒè¯
```tsx
// lib/validations.ts
import { z } from 'zod';

export const CreatePostSchema = z.object({
  title: z.string().min(1, 'Title is required').max(100),
  content: z.string().min(10, 'Content too short'),
  tags: z.string().optional()
});

// lib/actions.ts
'use server';
import { CreatePostSchema } from './validations';

export async function createPost(previousState: any, formData: FormData) {
  const rawData = {
    title: formData.get('title') as string,
    content: formData.get('content') as string,
    tags: formData.get('tags') as string
  };
  
  // éªŒè¯æ•°æ®
  const validation = CreatePostSchema.safeParse(rawData);
  
  if (!validation.success) {
    return {
      status: 'error',
      errors: validation.error.flatten().fieldErrors,
      message: 'Validation failed'
    };
  }
  
  try {
    await db.post.create({ data: validation.data });
    revalidatePath('/posts');
    return { status: 'success', message: 'Post created!' };
  } catch (error) {
    return { status: 'error', message: 'Failed to create post' };
  }
}
```

### æ¸è¿›å¼å¢å¼º
```tsx
// components/DeleteButton.tsx
'use client';
import { useActionState, useOptimistic } from 'react';
import { deletePost } from '@/lib/actions';

export function DeleteButton({ postId, onDelete }: { postId: string, onDelete?: () => void }) {
  const [state, formAction, isPending] = useActionState(deletePost, { status: '', message: '' });
  
  // ä¹è§‚æ›´æ–°ï¼šç«‹å³å“åº”ç”¨æˆ·æ“ä½œ
  const [optimisticDeleted, setOptimisticDeleted] = useOptimistic(false);
  
  if (optimisticDeleted) {
    return <span className="text-gray-500">Deleted...</span>;
  }
  
  return (
    <form action={async (formData) => {
      setOptimisticDeleted(true);
      onDelete?.(); // ç«‹å³ä» UI ä¸­ç§»é™¤
      await formAction(formData);
    }}>
      <input type="hidden" name="postId" value={postId} />
      <button 
        type="submit" 
        disabled={isPending}
        className="text-red-500 hover:text-red-700"
      >
        {isPending ? 'Deleting...' : 'Delete'}
      </button>
    </form>
  );
}
```

## âš ï¸ å¸¸è§é—®é¢˜ä¸è°ƒè¯•

### é—®é¢˜1ï¼šç¼“å­˜è¿‡åº¦ç§¯æ
**ç°è±¡ï¼š** æ•°æ®æ›´æ–°äº†ä½†é¡µé¢æ²¡æœ‰åæ˜ 
**è°ƒè¯•ï¼š**
```tsx
// åœ¨å¼€å‘ç¯å¢ƒç¦ç”¨ç¼“å­˜æ¥æµ‹è¯•
const data = await fetch('/api/data', { 
  cache: process.env.NODE_ENV === 'development' ? 'no-store' : 'default' 
});
```

### é—®é¢˜2ï¼šServer Action ä¸ç”Ÿæ•ˆ
**ç°è±¡ï¼š** è¡¨å•æäº¤æ²¡æœ‰æ‰§è¡Œ Action
**æ£€æŸ¥æ¸…å•ï¼š**
- ç¡®ä¿å‡½æ•°æ ‡è®°äº† `'use server'`
- ç¡®ä¿åœ¨ form çš„ action å±æ€§ä¸­ä½¿ç”¨
- æ£€æŸ¥ Next.js ç‰ˆæœ¬ï¼ˆéœ€è¦ 13.4+ï¼‰

### é—®é¢˜3ï¼šæ•°æ®è·å–æ—¶é—´è¿‡é•¿
**è°ƒè¯•å·¥å…·ï¼š**
```tsx
export default async function SlowPage() {
  const start = Date.now();
  
  try {
    const data = await fetch('/api/slow-endpoint');
    const duration = Date.now() - start;
    
    console.log(`Data fetching took ${duration}ms`);
    return <DataDisplay data={data} />;
  } catch (error) {
    console.error('Data fetching failed:', error);
    throw error;
  }
}
```

## ğŸ’¡ æ€§èƒ½ç›‘æ§

### æ·»åŠ æ€§èƒ½è¿½è¸ª
```tsx
// lib/performance.ts
export function withPerformanceTracking<T extends any[], R>(
  fn: (...args: T) => Promise<R>,
  name: string
) {
  return async (...args: T): Promise<R> => {
    const start = performance.now();
    try {
      const result = await fn(...args);
      const duration = performance.now() - start;
      
      // å‘é€åˆ°ç›‘æ§æœåŠ¡
      console.log(`[Performance] ${name}: ${duration.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      console.error(`[Performance] ${name} failed:`, error);
      throw error;
    }
  };
}

// ä½¿ç”¨ç¤ºä¾‹
const trackedFetch = withPerformanceTracking(
  async (url: string) => {
    const response = await fetch(url);
    return response.json();
  },
  'API_FETCH'
);
```

## ğŸ“ æœ€ä½³å®è·µæ£€æŸ¥è¡¨

- âœ… **ä¼˜å…ˆä½¿ç”¨ RSC ä¸­çš„ `async/await` è¿›è¡Œæ•°æ®è·å–**
- âœ… **åˆç†è®¾ç½®ç¼“å­˜ç­–ç•¥**ï¼ˆ`revalidate`, `no-store`, `tags`ï¼‰
- âœ… **å¹¶è¡Œè·å–ç›¸äº’ç‹¬ç«‹çš„æ•°æ®**
- âœ… **åœ¨ Server Actions ä¸­æ·»åŠ é”™è¯¯å¤„ç†å’ŒéªŒè¯**
- âœ… **ä½¿ç”¨ `useActionState` å¤„ç†è¡¨å•çŠ¶æ€**
- âœ… **ç›‘æ§æ•°æ®è·å–æ€§èƒ½**
- âœ… **è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´**
- âœ… **ä¸ºæ…¢æŸ¥è¯¢æ·»åŠ  loading çŠ¶æ€**