---
title: 'Vue2 Diff算法原理详解'
date: '2025-6-25'
overview: 'Vue2中的diff算法是Virtual DOM更新的核心机制，通过同层比较、key值匹配等策略实现高效的DOM更新。本文深入分析diff算法的执行流程、优化策略和实际应用。'
tags: 'Vue'
slug: 'vue2-diff-algorithm'
---

# Vue2 Diff算法原理详解

## 什么是Diff算法

Diff算法是Virtual DOM的核心，用来比较新旧虚拟节点树的差异，并以最小的代价更新真实DOM。

**核心思想：**

- 只比较同一层级的节点，不会跨层级
- 先判断节点类型是否相同
- 通过key值快速识别可复用的节点

## Diff算法整体流程

```mermaid
flowchart TD
    Start["开始diff"]
    CheckSame{"新旧节点是否相同？"}
    ReturnOld["直接返回旧节点"]
    CheckChildren{"是否都有子节点？"}
    UpdateChildren["updateChildren"]
    AddChildren["添加新子节点"]
    RemoveChildren["删除旧子节点"]
    UpdateText["更新文本内容"]
    UpdateDom["更新DOM"]
    End["结束"]

    Start --> CheckSame
    CheckSame -- 相同 --> ReturnOld
    CheckSame -- 不同 --> CheckChildren
    CheckChildren -- 都有 --> UpdateChildren
    CheckChildren -- 只有新节点有 --> AddChildren
    CheckChildren -- 只有旧节点有 --> RemoveChildren
    CheckChildren -- 都没有 --> UpdateText
    UpdateChildren --> UpdateDom
    AddChildren --> UpdateDom
    RemoveChildren --> UpdateDom
    UpdateText --> UpdateDom
    UpdateDom --> End

    %% 下面是加颜色的部分
    style Start fill:#6EE7B7,stroke:#22223B,stroke-width:2px
    style CheckSame fill:#FDE68A,stroke:#F59E42,stroke-width:2px
    style ReturnOld fill:#A7F3D0,stroke:#10B981,stroke-width:2px
    style CheckChildren fill:#FDE68A,stroke:#F59E42,stroke-width:2px
    style UpdateChildren fill:#93C5FD,stroke:#2563EB,stroke-width:2px
    style AddChildren fill:#FCA5A5,stroke:#EF4444,stroke-width:2px
    style RemoveChildren fill:#FCA5A5,stroke:#EF4444,stroke-width:2px
    style UpdateText fill:#FBCFE8,stroke:#DB2777,stroke-width:2px
    style UpdateDom fill:#DDD6FE,stroke:#7C3AED,stroke-width:2px
    style End fill:#D1FAE5,stroke:#10B981,stroke-width:2px
```

<img
  src="/diagrams/vue-Vue2 Diff算法原理详解-0.svg"
  alt="流程图：'开始diff'、'直接返回旧节点'、'updateChildren'"
  className="w-full max-w-4xl mx-auto my-6 rounded"
/>

## 节点比较策略

```mermaid
flowchart TD
    A[比较两个节点] --> B{tag相同}
    B -- 否 --> C[直接替换节点]
    B -- 是 --> D{key相同}
    D -- 否 --> C
    D -- 是 --> E[复用节点<br/>继续比较属性和子节点]
    E --> F[更新属性]
    F --> G[比较子节点]

    %% 颜色美化
    style A fill:#6EE7B7,stroke:#10B981,stroke-width:2px
    style B fill:#FDE68A,stroke:#F59E42,stroke-width:2px
    style C fill:#FCA5A5,stroke:#EF4444,stroke-width:2px
    style D fill:#FDE68A,stroke:#F59E42,stroke-width:2px
    style E fill:#A7F3D0,stroke:#10B981,stroke-width:2px
    style F fill:#93C5FD,stroke:#2563EB,stroke-width:2px
    style G fill:#DDD6FE,stroke:#7C3AED,stroke-width:2px

```

<img
  src="/diagrams/vue-Vue2 Diff算法原理详解-1.svg"
  alt="流程图：比较两个节点、直接替换节点、B"
  className="w-full lg:w-3/4 mx-auto my-6 rounded"
/>

## patch函数 - 入口函数

```js
function patch(oldVnode, vnode) {
  if (sameVnode(oldVnode, vnode)) {
    patchVnode(oldVnode, vnode)
  } else {
    const oEl = oldVnode.el
    let parentEle = api.parentNode(oEl)
    createEle(vnode)
    if (parentEle !== null) {
      api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))
      api.removeChild(parentEle, oldVnode.el)
      oldVnode = null
    }
  }
  return vnode
}
```

## sameVnode - 判断是否为相同节点

```js
function sameVnode(a, b) {
  return (
    a.key === b.key &&
    a.tag === b.tag &&
    a.isComment === b.isComment &&
    isDef(a.data) === isDef(b.data) &&
    sameInputType(a, b)
  )
}
```

## patchVnode - 比较相同节点

```js
function patchVnode(oldVnode, vnode) {
  const el = (vnode.el = oldVnode.el)
  if (oldVnode === vnode) return
  updateAttrs(oldVnode, vnode)
  const oldCh = oldVnode.children
  const ch = vnode.children
  if (isUndef(vnode.text)) {
    if (isDef(oldCh) && isDef(ch)) {
      if (oldCh !== ch) updateChildren(el, oldCh, ch)
    } else if (isDef(ch)) {
      if (isDef(oldVnode.text)) api.setTextContent(el, '')
      addVnodes(el, null, ch, 0, ch.length - 1)
    } else if (isDef(oldCh)) {
      removeVnodes(el, oldCh, 0, oldCh.length - 1)
    } else if (isDef(oldVnode.text)) {
      api.setTextContent(el, '')
    }
  } else if (oldVnode.text !== vnode.text) {
    api.setTextContent(el, vnode.text)
  }
}
```

## updateChildren - 双端比较算法

### 算法流程图

```mermaid
flowchart TD
    A[比较两个节点] --> B{tag相同}
    B -- 否 --> C[直接替换节点]
    B -- 是 --> D{key相同}
    D -- 否 --> C
    D -- 是 --> E[复用节点<br/>继续比较属性和子节点]
    E --> F[更新属性]
    F --> G[比较子节点]

    %% 颜色美化
    style A fill:#6EE7B7,stroke:#10B981,stroke-width:2px
    style B fill:#FDE68A,stroke:#F59E42,stroke-width:2px
    style C fill:#FCA5A5,stroke:#EF4444,stroke-width:2px
    style D fill:#FDE68A,stroke:#F59E42,stroke-width:2px
    style E fill:#A7F3D0,stroke:#10B981,stroke-width:2px
    style F fill:#93C5FD,stroke:#2563EB,stroke-width:2px
    style G fill:#DDD6FE,stroke:#7C3AED,stroke-width:2px
```

<img
  src="/diagrams/vue-Vue2 Diff算法原理详解-2.svg"
  alt="流程图：比较两个节点、直接替换节点、B"
  className="w-full lg:w-3/4 mx-auto my-6 rounded"
/>

## 逐步对比演示

### 例子：从 [A, B, C, D] 变成 [D, A, C, B]

#### 初始状态

```mermaid
graph TD
    subgraph "旧VNode数组"
        O1[A key=a]
        O2[B key=b]
        O3[C key=c]
        O4[D key=d]
    end
    subgraph "新VNode数组"
        N1[D key=d]
        N2[A key=a]
        N3[C key=c]
        N4[B key=b]
    end

    %% 颜色美化
    style O1 fill:#6EE7B7,stroke:#10B981,stroke-width:2px
    style O2 fill:#6EE7B7,stroke:#10B981,stroke-width:2px
    style O3 fill:#6EE7B7,stroke:#10B981,stroke-width:2px
    style O4 fill:#6EE7B7,stroke:#10B981,stroke-width:2px
    style N1 fill:#93C5FD,stroke:#2563EB,stroke-width:2px
    style N2 fill:#93C5FD,stroke:#2563EB,stroke-width:2px
    style N3 fill:#93C5FD,stroke:#2563EB,stroke-width:2px
    style N4 fill:#93C5FD,stroke:#2563EB,stroke-width:2px
```

<img
  src="/diagrams/vue-Vue2 Diff算法原理详解-3.svg"
  alt="流程图：A key=a、B key=b、C key=c"
  className="w-full my-4"
/>

#### 步骤1：尾头比较 D vs D，匹配，移动D到A前面

```mermaid
graph TD
    O4[D key=d] --匹配--> N1[D key=d]
    O4 -.移动到.-> O1

    %% 颜色美化
    style O4 fill:#A7F3D0,stroke:#10B981,stroke-width:2px
    style N1 fill:#A7F3D0,stroke:#10B981,stroke-width:2px
    style O1 fill:#FCA5A5,stroke:#EF4444,stroke-width:2px
```

<img
  src="/diagrams/vue-Vue2 Diff算法原理详解-4.svg"
  alt="流程图：D key=d"
  className="w-full lg:w-3/5 mx-auto my-6 rounded"
/>

操作：`insertBefore(D, A)`，指针移动 oldEnd--, newStart++

#### 步骤2：头头比较 A vs A，匹配，指针右移

```mermaid
graph TD
    O1[A key=a] --匹配--> N2[A key=a]

    %% 颜色美化
    style O1 fill:#A7F3D0,stroke:#10B981,stroke-width:2px
    style N2 fill:#A7F3D0,stroke:#10B981,stroke-width:2px
```

<div className="flex justify-center">
  <img
    src="/diagrams/vue-Vue2 Diff算法原理详解-5.svg"
    alt="流程图：A key=a"
    className="w-1/2 lg:w-1/4 mx-auto my-6 rounded"
  />
</div>

#### 步骤3：头尾比较 B vs B，匹配，移动B到C后面

```mermaid
graph TD
    O2[B key=b] --匹配--> N4[B key=b]
    O2 -.移动到.-> O3

    %% 颜色美化
    style O2 fill:#A7F3D0,stroke:#10B981,stroke-width:2px
    style N4 fill:#A7F3D0,stroke:#10B981,stroke-width:2px
    style O3 fill:#FCA5A5,stroke:#EF4444,stroke-width:2px
```

<div className="flex justify-center">
  <img
    src="/diagrams/vue-Vue2 Diff算法原理详解-6.svg"
    alt="流程图：B key=b"
    className="w-full lg:w-3/5 mx-auto my-6 rounded"
  />
</div>

#### 步骤4：头头比较 C vs C，匹配，指针右移

```mermaid
graph TD
    O3[C key=c] --匹配--> N3[C key=c]

    %% 颜色美化
    style O3 fill:#A7F3D0,stroke:#10B981,stroke-width:2px
    style N3 fill:#A7F3D0,stroke:#10B981,stroke-width:2px
```

<div className="flex justify-center">
  <img
    src="/diagrams/vue-Vue2 Diff算法原理详解-7.svg"
    alt="流程图：C key=c"
    className="w-3/5 lg:w-1/3 mx-auto my-6 rounded"
  />
</div>

#### 最终结果

```mermaid
graph TD
    D1[D] --> D2[A] --> D3[C] --> D4[B]

    %% 颜色美化
    style D1 fill:#DDD6FE,stroke:#7C3AED,stroke-width:2px
    style D2 fill:#DDD6FE,stroke:#7C3AED,stroke-width:2px
    style D3 fill:#DDD6FE,stroke:#7C3AED,stroke-width:2px
    style D4 fill:#DDD6FE,stroke:#7C3AED,stroke-width:2px
```

<div className="flex justify-center">
  <img
    src="/diagrams/vue-Vue2 Diff算法原理详解-8.svg"
    alt="流程图：D"
    className="w-1/4 lg:w-1/6 mx-auto my-6 rounded"
  />
</div>

## updateChildren核心代码

```js
function updateChildren(parentElm, oldCh, newCh) {
  // 初始化双端比较的指针
  let oldStartIdx = 0                    // 旧子节点数组的起始索引
  let newStartIdx = 0                    // 新子节点数组的起始索引
  let oldEndIdx = oldCh.length - 1       // 旧子节点数组的结束索引
  let oldStartVnode = oldCh[0]           // 旧子节点数组的第一个节点
  let oldEndVnode = oldCh[oldEndIdx]     // 旧子节点数组的最后一个节点
  let newEndIdx = newCh.length - 1       // 新子节点数组的结束索引
  let newStartVnode = newCh[0]           // 新子节点数组的第一个节点
  let newEndVnode = newCh[newEndIdx]     // 新子节点数组的最后一个节点
  
  // 用于key查找的辅助变量
  let oldKeyToIdx, idxInOld, vnodeToMove, refElm

  // 创建key到索引的映射表，用于快速查找
  function createKeyToOldIdx(children, beginIdx, endIdx) {
    let i, key
    const map = {}
    for (i = beginIdx; i <= endIdx; ++i) {
      key = children[i].key
      if (isDef(key)) map[key] = i  // 将key作为键，索引作为值
    }
    return map
  }

  // 双端比较的主循环
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    // 情况1：跳过已处理的旧节点（被设置为undefined）
    if (isUndef(oldStartVnode)) {
      oldStartVnode = oldCh[++oldStartIdx]
    } else if (isUndef(oldEndVnode)) {
      oldEndVnode = oldCh[--oldEndIdx]
    } 
    // 情况2：头头比较 - 新旧起始节点相同
    else if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(oldStartVnode, newStartVnode)  // 更新节点
      oldStartVnode = oldCh[++oldStartIdx]      // 旧起始指针右移
      newStartVnode = newCh[++newStartIdx]      // 新起始指针右移
    } 
    // 情况3：尾尾比较 - 新旧结束节点相同
    else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode)      // 更新节点
      oldEndVnode = oldCh[--oldEndIdx]          // 旧结束指针左移
      newEndVnode = newCh[--newEndIdx]          // 新结束指针左移
    } 
    // 情况4：头尾比较 - 旧起始节点与新结束节点相同
    else if (sameVnode(oldStartVnode, newEndVnode)) {
      patchVnode(oldStartVnode, newEndVnode)    // 更新节点
      // 将旧起始节点移动到旧结束节点之后
      api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))
      oldStartVnode = oldCh[++oldStartIdx]      // 旧起始指针右移
      newEndVnode = newCh[--newEndIdx]          // 新结束指针左移
    } 
    // 情况5：尾头比较 - 旧结束节点与新起始节点相同
    else if (sameVnode(oldEndVnode, newStartVnode)) {
      patchVnode(oldEndVnode, newStartVnode)    // 更新节点
      // 将旧结束节点移动到旧起始节点之前
      api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)
      oldEndVnode = oldCh[--oldEndIdx]          // 旧结束指针左移
      newStartVnode = newCh[++newStartIdx]      // 新起始指针右移
    } 
    // 情况6：四种双端比较都不匹配，使用key查找
    else {
      // 懒加载创建key映射表
      if (isUndef(oldKeyToIdx)) {
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
      }
      
      // 根据新起始节点的key在旧节点中查找
      idxInOld = isDef(newStartVnode.key)
        ? oldKeyToIdx[newStartVnode.key]  // 有key时直接查找
        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)  // 无key时遍历查找
      
      // 在旧节点中找不到相同key的节点
      if (isUndef(idxInOld)) {
        createElm(newStartVnode, parentElm, oldStartVnode.el)  // 创建新节点
      } else {
        // 找到了相同key的旧节点
        vnodeToMove = oldCh[idxInOld]
        if (sameVnode(vnodeToMove, newStartVnode)) {
          // 节点类型也相同，可以复用
          patchVnode(vnodeToMove, newStartVnode)  // 更新节点
          oldCh[idxInOld] = undefined             // 标记旧节点已处理
          api.insertBefore(parentElm, vnodeToMove.el, oldStartVnode.el)  // 移动到新位置
        } else {
          // 节点类型不同，创建新节点
          createElm(newStartVnode, parentElm, oldStartVnode.el)
        }
      }
      newStartVnode = newCh[++newStartIdx]  // 新起始指针右移
    }
  }
  
  // 处理剩余节点
  if (oldStartIdx > oldEndIdx) {
    // 旧节点处理完毕，新节点还有剩余，需要添加
    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].el
    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx)
  } else if (newStartIdx > newEndIdx) {
    // 新节点处理完毕，旧节点还有剩余，需要删除
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
  }
}
```

## key的重要性对比

```js
// 没有key的情况
<ul>
  <li>张三</li>
  <li>李四</li>
  <li>王五</li>
</ul>

// 插入一个新项到开头
<ul>
  <li>赵六</li>
  <li>张三</li>
  <li>李四</li>
  <li>王五</li>
</ul>
// 需要修改3个节点 + 创建1个节点

// 有key的情况
<ul>
  <li key="zhang">张三</li>
  <li key="li">李四</li>
  <li key="wang">王五</li>
</ul>

// 插入一个新项到开头
<ul>
  <li key="zhao">赵六</li>
  <li key="zhang">张三</li>
  <li key="li">李四</li>
  <li key="wang">王五</li>
</ul>
// 只需创建1个节点，其他节点直接复用
```

## 算法复杂度与优化

```mermaid
graph TD
    A["Diff算法复杂度"] --> B["最好 O(n)"]
    A --> C["最坏 O(n²)"]
    A --> D["平均 O(n)"]
    B --> B1["大部分节点能快速匹配"]
    C --> C1["每次都需要遍历查找 key"]
    D --> D1["大部分节点能快速匹配"]

    %% 颜色美化
    style A fill:#6EE7B7,stroke:#10B981,stroke-width:2px
    style B fill:#A7F3D0,stroke:#10B981,stroke-width:2px
    style C fill:#FCA5A5,stroke:#EF4444,stroke-width:2px
    style D fill:#93C5FD,stroke:#2563EB,stroke-width:2px
    style B1 fill:#A7F3D0,stroke:#10B981,stroke-width:2px
    style C1 fill:#FCA5A5,stroke:#EF4444,stroke-width:2px
    style D1 fill:#93C5FD,stroke:#2563EB,stroke-width:2px
```

<img
  src="/diagrams/vue-Vue2 Diff算法原理详解-9.svg"
  alt="流程图：'Diff算法复杂度'、'最坏 O(n²)'、'平均 O(n)'"
  className="w-full mx-auto my-6 rounded"
/>

## 面试总结

- Vue2 diff算法只做同层比较，避免O(n³)复杂度
- 采用双端比较（头头、尾尾、头尾、尾头）+ key查找，平均O(n)
- key的作用是帮助节点复用，提升性能，避免状态错乱
- 实际开发中，key应选用唯一且稳定的标识
- Vue3在此基础上引入了最长递增子序列优化节点移动

**记忆口诀：**

- 同层比较不跨级
- 双端比较四种情况
- key值定位要精确
- 就地复用性能好

这就是Vue2 Diff算法的核心原理和执行流程，配合流程图和例子，面试时可以自信讲解。
